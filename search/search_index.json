{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"NanoCLI","text":"<p>A cli framework with the simplicity of argparse, the colors of rich, the config handling of Hydra, and without the complexity.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install nanocli\n</code></pre>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>from dataclasses import dataclass\nfrom nanocli import group\n\n@dataclass\nclass TrainConfig:\n    epochs: int = 100\n    lr: float = 0.001\n\napp = group()\n\n@app.command()\ndef train(cfg: TrainConfig):\n    print(f\"Training for {cfg.epochs} epochs\")\n\nif __name__ == \"__main__\":\n    app()\n</code></pre>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Type-safe configs from dataclasses</li> <li>Nested groups as a unified tree structure</li> <li>YAML configs with dotted-path overrides</li> <li>Rich help output with colors</li> <li>Zero boilerplate - your function signature IS the CLI</li> </ul>"},{"location":"api/","title":"API Reference","text":""},{"location":"api/#overview","title":"Overview","text":"<p>NanoCLI provides two main modules:</p> <ul> <li>Core - CLI framework (<code>group</code>, <code>run</code>, <code>NanoCLI</code>)</li> <li>Config - Configuration handling (<code>compile_config</code>, <code>load_yaml</code>, <code>option</code>)</li> </ul>"},{"location":"config/","title":"Config Module","text":""},{"location":"config/#nanocli.config.option","title":"nanocli.config.option","text":"<pre><code>option(\n    default: Any = MISSING, *, help: str = \"\", **kwargs: Any\n) -&gt; Any\n</code></pre> <p>Dataclass field wrapper with help text for CLI.</p> <p>Use this instead of <code>field()</code> to add help text that appears in CLI help.</p> <p>Parameters:</p> Name Type Description Default <code>default</code> <code>Any</code> <p>Default value for the field.</p> <code>MISSING</code> <code>help</code> <code>str</code> <p>Help text shown in CLI.</p> <code>''</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to <code>dataclasses.field()</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Any</code> <p>A dataclass field with metadata.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from dataclasses import dataclass\n&gt;&gt;&gt; @dataclass\n... class Config:\n...     epochs: int = option(100, help=\"Number of epochs\")\n...     lr: float = option(0.001, help=\"Learning rate\")\n&gt;&gt;&gt; cfg = Config()\n&gt;&gt;&gt; cfg.epochs\n100\n</code></pre> Source code in <code>src/nanocli/config.py</code> <pre><code>def option(\n    default: Any = MISSING,\n    *,\n    help: str = \"\",\n    **kwargs: Any,\n) -&gt; Any:\n    \"\"\"Dataclass field wrapper with help text for CLI.\n\n    Use this instead of `field()` to add help text that appears in CLI help.\n\n    Args:\n        default: Default value for the field.\n        help: Help text shown in CLI.\n        **kwargs: Additional arguments passed to `dataclasses.field()`.\n\n    Returns:\n        A dataclass field with metadata.\n\n    Examples:\n        &gt;&gt;&gt; from dataclasses import dataclass\n        &gt;&gt;&gt; @dataclass\n        ... class Config:\n        ...     epochs: int = option(100, help=\"Number of epochs\")\n        ...     lr: float = option(0.001, help=\"Learning rate\")\n        &gt;&gt;&gt; cfg = Config()\n        &gt;&gt;&gt; cfg.epochs\n        100\n    \"\"\"\n    metadata = kwargs.pop(\"metadata\", {})\n    metadata[\"help\"] = help\n    return field(default=default, metadata=metadata, **kwargs)\n</code></pre>"},{"location":"config/#nanocli.config.compile_config","title":"nanocli.config.compile_config","text":"<pre><code>compile_config(\n    base: DictConfig | None = None,\n    overrides: list[str] | None = None,\n    schema: type[T] | None = None,\n) -&gt; DictConfig | T\n</code></pre> <p>Compile a config from base + overrides.</p> <p>This is the core function: pure tree rewrite. Priority: schema defaults &lt; base &lt; overrides</p> <p>Parameters:</p> Name Type Description Default <code>base</code> <code>DictConfig | None</code> <p>Base config tree (from YAML).</p> <code>None</code> <code>overrides</code> <code>list[str] | None</code> <p>List of override strings (<code>key=value</code>, <code>key=@file</code>).</p> <code>None</code> <code>schema</code> <code>type[T] | None</code> <p>Optional dataclass for type validation.</p> <code>None</code> <p>Returns:</p> Type Description <code>DictConfig | T</code> <p>Compiled config. Typed if schema provided, else DictConfig.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from dataclasses import dataclass\n&gt;&gt;&gt; @dataclass\n... class Config:\n...     name: str = \"default\"\n...     count: int = 1\n&gt;&gt;&gt; cfg = compile_config(schema=Config)\n&gt;&gt;&gt; cfg.name\n'default'\n&gt;&gt;&gt; cfg = compile_config(schema=Config, overrides=[\"name=custom\"])\n&gt;&gt;&gt; cfg.name\n'custom'\n</code></pre> Source code in <code>src/nanocli/config.py</code> <pre><code>def compile_config(\n    base: DictConfig | None = None,\n    overrides: list[str] | None = None,\n    schema: type[T] | None = None,\n) -&gt; DictConfig | T:\n    \"\"\"Compile a config from base + overrides.\n\n    This is the core function: pure tree rewrite.\n    Priority: schema defaults &lt; base &lt; overrides\n\n    Args:\n        base: Base config tree (from YAML).\n        overrides: List of override strings (`key=value`, `key=@file`).\n        schema: Optional dataclass for type validation.\n\n    Returns:\n        Compiled config. Typed if schema provided, else DictConfig.\n\n    Examples:\n        &gt;&gt;&gt; from dataclasses import dataclass\n        &gt;&gt;&gt; @dataclass\n        ... class Config:\n        ...     name: str = \"default\"\n        ...     count: int = 1\n        &gt;&gt;&gt; cfg = compile_config(schema=Config)\n        &gt;&gt;&gt; cfg.name\n        'default'\n        &gt;&gt;&gt; cfg = compile_config(schema=Config, overrides=[\"name=custom\"])\n        &gt;&gt;&gt; cfg.name\n        'custom'\n    \"\"\"\n    # Build config: schema defaults -&gt; base -&gt; overrides\n    if schema is not None:\n        cfg = OmegaConf.structured(schema)\n        if base is not None:\n            cfg = OmegaConf.merge(cfg, base)\n    else:\n        cfg = base if base is not None else OmegaConf.create({})\n\n    # Apply overrides (tree rewrite)\n    if overrides:\n        override_cfg = parse_overrides(overrides)\n        try:\n            cfg = OmegaConf.merge(cfg, override_cfg)\n        except Exception as e:\n            # Extract the key from OmegaConf error message\n            error_msg = str(e)\n            if \"Key\" in error_msg and \"not in\" in error_msg:\n                # Parse: Key 'typer' not in 'ModelConfig'\n                import re\n\n                match = re.search(r\"Key '(\\w+)' not in '(\\w+)'\", error_msg)\n                if match:\n                    key, cls = match.groups()\n                    raise ConfigError(\n                        f\"Invalid config key '{key}' in '{cls}'. Check for typos in your overrides.\"\n                    ) from None\n            # Re-raise with friendlier message\n            raise ConfigError(f\"Config error: {error_msg}\") from None\n\n    # Convert to typed object if schema provided\n    if schema is not None:\n        return OmegaConf.to_object(cfg)  # type: ignore[return-value]\n\n    return cfg  # type: ignore[no-any-return]\n</code></pre>"},{"location":"config/#nanocli.config.load_yaml","title":"nanocli.config.load_yaml","text":"<pre><code>load_yaml(path: str | Path) -&gt; DictConfig\n</code></pre> <p>Load a YAML file into a DictConfig.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to the YAML file.</p> required <p>Returns:</p> Type Description <code>DictConfig</code> <p>DictConfig containing the parsed YAML.</p> <p>Raises:</p> Type Description <code>ConfigError</code> <p>If the file does not exist.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; with tempfile.NamedTemporaryFile(suffix=\".yml\", delete=False, mode=\"w\") as f:\n...     _ = f.write(\"name: test\\ncount: 42\")\n...     path = f.name\n&gt;&gt;&gt; cfg = load_yaml(path)\n&gt;&gt;&gt; cfg.name\n'test'\n&gt;&gt;&gt; Path(path).unlink()\n</code></pre> Source code in <code>src/nanocli/config.py</code> <pre><code>def load_yaml(path: str | Path) -&gt; DictConfig:\n    \"\"\"Load a YAML file into a DictConfig.\n\n    Args:\n        path: Path to the YAML file.\n\n    Returns:\n        DictConfig containing the parsed YAML.\n\n    Raises:\n        ConfigError: If the file does not exist.\n\n    Examples:\n        &gt;&gt;&gt; import tempfile\n        &gt;&gt;&gt; from pathlib import Path\n        &gt;&gt;&gt; with tempfile.NamedTemporaryFile(suffix=\".yml\", delete=False, mode=\"w\") as f:\n        ...     _ = f.write(\"name: test\\\\ncount: 42\")\n        ...     path = f.name\n        &gt;&gt;&gt; cfg = load_yaml(path)\n        &gt;&gt;&gt; cfg.name\n        'test'\n        &gt;&gt;&gt; Path(path).unlink()\n    \"\"\"\n    path = Path(path)\n    if not path.exists():\n        raise ConfigError(f\"Config file not found: {path}\")\n    return OmegaConf.load(path)  # type: ignore[return-value]\n</code></pre>"},{"location":"config/#nanocli.config.to_yaml","title":"nanocli.config.to_yaml","text":"<pre><code>to_yaml(config: Any) -&gt; str\n</code></pre> <p>Convert config to YAML string.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Any</code> <p>Config object (dataclass, dict, or DictConfig).</p> required <p>Returns:</p> Type Description <code>str</code> <p>YAML string representation.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from dataclasses import dataclass\n&gt;&gt;&gt; @dataclass\n... class Config:\n...     name: str = \"test\"\n&gt;&gt;&gt; yaml_str = to_yaml(Config())\n&gt;&gt;&gt; \"name: test\" in yaml_str\nTrue\n</code></pre> Source code in <code>src/nanocli/config.py</code> <pre><code>def to_yaml(config: Any) -&gt; str:\n    \"\"\"Convert config to YAML string.\n\n    Args:\n        config: Config object (dataclass, dict, or DictConfig).\n\n    Returns:\n        YAML string representation.\n\n    Examples:\n        &gt;&gt;&gt; from dataclasses import dataclass\n        &gt;&gt;&gt; @dataclass\n        ... class Config:\n        ...     name: str = \"test\"\n        &gt;&gt;&gt; yaml_str = to_yaml(Config())\n        &gt;&gt;&gt; \"name: test\" in yaml_str\n        True\n    \"\"\"\n    if is_dataclass(config) and not isinstance(config, type):\n        cfg = OmegaConf.structured(config)\n    elif isinstance(config, DictConfig):\n        cfg = config\n    else:\n        cfg = OmegaConf.create(config)\n\n    return OmegaConf.to_yaml(cfg)\n</code></pre>"},{"location":"config/#nanocli.config.save_yaml","title":"nanocli.config.save_yaml","text":"<pre><code>save_yaml(config: Any, path: str | Path) -&gt; None\n</code></pre> <p>Save config to YAML file.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Any</code> <p>Config object to save.</p> required <code>path</code> <code>str | Path</code> <p>Path to write the YAML file.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from dataclasses import dataclass\n&gt;&gt;&gt; @dataclass\n... class Config:\n...     name: str = \"test\"\n&gt;&gt;&gt; with tempfile.NamedTemporaryFile(suffix=\".yml\", delete=False) as f:\n...     save_yaml(Config(), f.name)\n...     content = open(f.name).read()\n&gt;&gt;&gt; \"name: test\" in content\nTrue\n</code></pre> Source code in <code>src/nanocli/config.py</code> <pre><code>def save_yaml(config: Any, path: str | Path) -&gt; None:\n    \"\"\"Save config to YAML file.\n\n    Args:\n        config: Config object to save.\n        path: Path to write the YAML file.\n\n    Examples:\n        &gt;&gt;&gt; import tempfile\n        &gt;&gt;&gt; from dataclasses import dataclass\n        &gt;&gt;&gt; @dataclass\n        ... class Config:\n        ...     name: str = \"test\"\n        &gt;&gt;&gt; with tempfile.NamedTemporaryFile(suffix=\".yml\", delete=False) as f:\n        ...     save_yaml(Config(), f.name)\n        ...     content = open(f.name).read()\n        &gt;&gt;&gt; \"name: test\" in content\n        True\n    \"\"\"\n    Path(path).write_text(to_yaml(config))\n</code></pre>"},{"location":"config/#nanocli.config.parse_overrides","title":"nanocli.config.parse_overrides","text":"<pre><code>parse_overrides(overrides: list[str]) -&gt; DictConfig\n</code></pre> <p>Parse CLI overrides into a config tree.</p> <p>Supports three types of overrides: - <code>key=value</code> - Scalar override - <code>key.path=value</code> - Nested override - <code>key=@file.yml</code> - Subtree replacement from file</p> <p>Parameters:</p> Name Type Description Default <code>overrides</code> <code>list[str]</code> <p>List of override strings.</p> required <p>Returns:</p> Type Description <code>DictConfig</code> <p>DictConfig with parsed overrides.</p> <p>Raises:</p> Type Description <code>ConfigError</code> <p>If an override doesn't contain '='.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; cfg = parse_overrides([\"name=test\", \"count=42\"])\n&gt;&gt;&gt; cfg.name\n'test'\n&gt;&gt;&gt; cfg.count\n42\n&gt;&gt;&gt; cfg = parse_overrides([\"model.layers=24\"])\n&gt;&gt;&gt; cfg.model.layers\n24\n</code></pre> Source code in <code>src/nanocli/config.py</code> <pre><code>def parse_overrides(overrides: list[str]) -&gt; DictConfig:\n    \"\"\"Parse CLI overrides into a config tree.\n\n    Supports three types of overrides:\n    - `key=value` - Scalar override\n    - `key.path=value` - Nested override\n    - `key=@file.yml` - Subtree replacement from file\n\n    Args:\n        overrides: List of override strings.\n\n    Returns:\n        DictConfig with parsed overrides.\n\n    Raises:\n        ConfigError: If an override doesn't contain '='.\n\n    Examples:\n        &gt;&gt;&gt; cfg = parse_overrides([\"name=test\", \"count=42\"])\n        &gt;&gt;&gt; cfg.name\n        'test'\n        &gt;&gt;&gt; cfg.count\n        42\n        &gt;&gt;&gt; cfg = parse_overrides([\"model.layers=24\"])\n        &gt;&gt;&gt; cfg.model.layers\n        24\n    \"\"\"\n    result: dict[str, Any] = {}\n\n    for override in overrides:\n        if \"=\" not in override:\n            raise ConfigError(f\"Invalid override: '{override}'. Expected 'key=value' format.\")\n\n        key, value = override.split(\"=\", 1)\n        key = key.strip()\n        value = value.strip()\n\n        # Handle @file syntax for subtree replacement\n        if value.startswith(\"@\"):\n            file_path = value[1:]\n            parsed = OmegaConf.to_container(load_yaml(file_path))\n        else:\n            parsed = _parse_value(value)\n\n        # Build nested dict from dot notation\n        _set_nested(result, key.split(\".\"), parsed)\n\n    return OmegaConf.create(result)\n</code></pre>"},{"location":"config/#nanocli.config.ConfigError","title":"nanocli.config.ConfigError","text":"<p>               Bases: <code>Exception</code></p> <p>Configuration-related errors.</p> <p>Raised when config files are missing, overrides are invalid, etc.</p> Source code in <code>src/nanocli/config.py</code> <pre><code>class ConfigError(Exception):\n    \"\"\"Configuration-related errors.\n\n    Raised when config files are missing, overrides are invalid, etc.\n    \"\"\"\n</code></pre>"},{"location":"core/","title":"Core Module","text":""},{"location":"core/#nanocli.core.group","title":"nanocli.core.group","text":"<pre><code>group(\n    name: str | None = None, help: str | None = None\n) -&gt; NanoCLI\n</code></pre> <p>Create a command group (CLI entry point).</p> <p>This is the main entry point for creating a CLI application.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>Name of the CLI application.</p> <code>None</code> <code>help</code> <code>str | None</code> <p>Help text shown in CLI help.</p> <code>None</code> <p>Returns:</p> Type Description <code>NanoCLI</code> <p>NanoCLI instance.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; app = group(name=\"myapp\")\n&gt;&gt;&gt; isinstance(app, NanoCLI)\nTrue\n&gt;&gt;&gt; @app.command()\n... def train(cfg):\n...     pass\n&gt;&gt;&gt; \"train\" in app._commands\nTrue\n</code></pre> Source code in <code>src/nanocli/core.py</code> <pre><code>def group(name: str | None = None, help: str | None = None) -&gt; NanoCLI:\n    \"\"\"Create a command group (CLI entry point).\n\n    This is the main entry point for creating a CLI application.\n\n    Args:\n        name: Name of the CLI application.\n        help: Help text shown in CLI help.\n\n    Returns:\n        NanoCLI instance.\n\n    Examples:\n        &gt;&gt;&gt; app = group(name=\"myapp\")\n        &gt;&gt;&gt; isinstance(app, NanoCLI)\n        True\n        &gt;&gt;&gt; @app.command()\n        ... def train(cfg):\n        ...     pass\n        &gt;&gt;&gt; \"train\" in app._commands\n        True\n    \"\"\"\n    return NanoCLI(name=name, help=help)\n</code></pre>"},{"location":"core/#nanocli.core.run","title":"nanocli.core.run","text":"<pre><code>run(\n    schema_or_func: type[T] | Any,\n    args: list[str] | None = None,\n) -&gt; T | Any\n</code></pre> <p>Run a single-command CLI from a config schema or function.</p> <p>This provides a simple API for single-command CLIs without groups.</p> <p>Parameters:</p> Name Type Description Default <code>schema_or_func</code> <code>type[T] | Any</code> <p>A dataclass type (returns compiled config) or a callable (infers schema from type hints and executes).</p> required <code>args</code> <code>list[str] | None</code> <p>CLI arguments. Defaults to sys.argv[1:].</p> <code>None</code> <p>Returns:</p> Type Description <code>T | Any</code> <p>Compiled config if schema provided, or function return value.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If function has no dataclass argument.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from dataclasses import dataclass\n&gt;&gt;&gt; @dataclass\n... class Config:\n...     name: str = \"world\"\n&gt;&gt;&gt; cfg = run(Config, args=[])\n&gt;&gt;&gt; cfg.name\n'world'\n</code></pre> Source code in <code>src/nanocli/core.py</code> <pre><code>def run(\n    schema_or_func: type[T] | Any,\n    args: list[str] | None = None,\n) -&gt; T | Any:\n    \"\"\"Run a single-command CLI from a config schema or function.\n\n    This provides a simple API for single-command CLIs without groups.\n\n    Args:\n        schema_or_func: A dataclass type (returns compiled config) or\n            a callable (infers schema from type hints and executes).\n        args: CLI arguments. Defaults to sys.argv[1:].\n\n    Returns:\n        Compiled config if schema provided, or function return value.\n\n    Raises:\n        ValueError: If function has no dataclass argument.\n\n    Examples:\n        &gt;&gt;&gt; from dataclasses import dataclass\n        &gt;&gt;&gt; @dataclass\n        ... class Config:\n        ...     name: str = \"world\"\n        &gt;&gt;&gt; cfg = run(Config, args=[])\n        &gt;&gt;&gt; cfg.name\n        'world'\n    \"\"\"\n    from typing import get_type_hints\n\n    console = Console()\n\n    # Detect mode: Schema or Function\n    func_to_run = None\n    schema = schema_or_func\n\n    if not isinstance(schema_or_func, type) and callable(schema_or_func):\n        func_to_run = schema_or_func\n        # Infer schema from function signature\n        hints = get_type_hints(func_to_run)\n        found_schema = None\n        for pname, ptype in hints.items():\n            if pname != \"return\" and is_dataclass(ptype):\n                found_schema = ptype\n                break\n\n        if not found_schema:\n            raise ValueError(\n                f\"Could not infer config schema from function {func_to_run.__name__}. Ensure one argument is a dataclass.\"\n            )\n\n        schema = found_schema\n\n    if args is None:\n        args = sys.argv[1:]\n\n    path_parts, overrides, flags = parse_args(args)\n\n    # Handle help\n    if flags[\"help\"]:\n        _show_run_help(console, schema)\n        return None\n\n    # Load base config\n    cfg_file = flags[\"cfg\"]\n    base = load_yaml(cfg_file) if cfg_file else None\n\n    # Compile config\n    try:\n        config = compile_config(base=base, overrides=overrides, schema=schema)\n    except ConfigError as e:\n        console.print(f\"[red]Error:[/red] {e}\")\n        console.print()\n        _show_run_help(console, schema)\n        sys.exit(1)\n\n    # Handle print\n    if flags[\"print\"] or flags[\"print_global\"]:\n        console.print(to_yaml(config), end=\"\")\n        return config\n\n    # Execute function if provided\n    if func_to_run:\n        return func_to_run(config)\n\n    return config\n</code></pre>"},{"location":"core/#nanocli.core.NanoCLI","title":"nanocli.core.NanoCLI","text":"<p>Unified CLI tree for command groups and commands.</p> <p>The CLI is structured as a tree where groups are non-leaf nodes and commands are leaf nodes with associated config schemas.</p> <p>Attributes:</p> Name Type Description <code>_name</code> <p>Name of this group.</p> <code>_help</code> <p>Help text for this group.</p> <code>_parent</code> <p>Parent NanoCLI instance (None for root).</p> <code>_commands</code> <code>dict[str, tuple[Callable[..., Any], type | None]]</code> <p>Registered commands.</p> <code>_groups</code> <code>dict[str, NanoCLI]</code> <p>Nested groups.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; app = NanoCLI(name=\"myapp\")\n&gt;&gt;&gt; @app.command()\n... def hello(cfg):\n...     print(\"Hello!\")\n&gt;&gt;&gt; \"hello\" in app._commands\nTrue\n</code></pre> Source code in <code>src/nanocli/core.py</code> <pre><code>class NanoCLI:\n    \"\"\"Unified CLI tree for command groups and commands.\n\n    The CLI is structured as a tree where groups are non-leaf nodes\n    and commands are leaf nodes with associated config schemas.\n\n    Attributes:\n        _name: Name of this group.\n        _help: Help text for this group.\n        _parent: Parent NanoCLI instance (None for root).\n        _commands: Registered commands.\n        _groups: Nested groups.\n\n    Examples:\n        &gt;&gt;&gt; app = NanoCLI(name=\"myapp\")\n        &gt;&gt;&gt; @app.command()\n        ... def hello(cfg):\n        ...     print(\"Hello!\")\n        &gt;&gt;&gt; \"hello\" in app._commands\n        True\n    \"\"\"\n\n    def __init__(\n        self,\n        name: str | None = None,\n        help: str | None = None,\n        parent: \"NanoCLI | None\" = None,\n    ):\n        self._name = name\n        self._help = help\n        self._parent = parent\n        self._commands: dict[str, tuple[Callable[..., Any], type | None]] = {}\n        self._groups: dict[str, NanoCLI] = {}\n\n    def __call__(self, args: list[str] | None = None) -&gt; None:\n        \"\"\"Run the CLI.\"\"\"\n        if args is None:\n            args = sys.argv[1:]\n\n        self._execute(args)\n\n    def _get_root(self) -&gt; \"NanoCLI\":\n        \"\"\"Get the root NanoCLI by traversing up the parent chain.\"\"\"\n        current = self\n        while current._parent is not None:\n            current = current._parent\n        return current\n\n    def _get_path(self) -&gt; str:\n        \"\"\"Get the dotted path from root to this group.\"\"\"\n        path_parts = []\n        current = self\n        while current._parent is not None:\n            if current._name:\n                path_parts.append(current._name)\n            current = current._parent\n        return \".\".join(reversed(path_parts))\n\n    def _collect_configs(\n        self, cfg_file: str | None, overrides: list[str], prefix: str = \"\"\n    ) -&gt; dict[str, Any]:\n        \"\"\"Recursively collect configs from all commands and groups.\"\"\"\n        configs: dict[str, Any] = {}\n\n        for cmd_name, (_, schema) in self._commands.items():\n            if schema is not None:\n                full_name = f\"{prefix}{cmd_name}\" if prefix else cmd_name\n                cmd_overrides = []\n                for ov in overrides:\n                    if ov.startswith(f\"{full_name}.\"):\n                        cmd_overrides.append(ov[len(full_name) + 1 :])\n                    elif \".\" not in ov.split(\"=\")[0]:\n                        cmd_overrides.append(ov)\n\n                base = load_yaml(cfg_file) if cfg_file else None\n                config = compile_config(base=base, overrides=cmd_overrides, schema=schema)\n                configs[cmd_name] = config\n\n        for group_name, sub_app in self._groups.items():\n            configs[group_name] = sub_app._collect_configs(\n                cfg_file, overrides, f\"{prefix}{group_name}.\"\n            )\n\n        return configs\n\n    def _execute(self, args: list[str]) -&gt; None:\n        \"\"\"Execute the CLI with given arguments.\"\"\"\n        path_parts, overrides, flags = parse_args(args)\n        console = Console()\n\n        # Handle help at current level\n        if flags[\"help\"] and not path_parts:\n            self._show_help(console)\n            return\n\n        # Find the target node (traverse path)\n        current = self\n        consumed_path = []\n\n        for part in path_parts:\n            if part in current._groups:\n                consumed_path.append(part)\n                current = current._groups[part]\n            elif part in current._commands:\n                consumed_path.append(part)\n                # Found a command - execute it\n                func, schema = current._commands[part]\n\n                if flags[\"help\"]:\n                    current._show_command_help(console, part, schema)\n                    return\n\n                # Get cfg file\n                cfg_file = flags[\"cfg\"]\n                base = load_yaml(cfg_file) if cfg_file else None\n\n                # Compile config\n                if schema:\n                    try:\n                        config = compile_config(base=base, overrides=overrides, schema=schema)\n                    except ConfigError as e:\n                        console.print(f\"[red]Error:[/red] {e}\")\n                        console.print()\n                        current._show_command_help(console, part, schema)\n                        sys.exit(1)\n                else:\n                    config = None\n\n                if flags[\"print\"]:\n                    # Print just this command's config\n                    if config:\n                        console.print(to_yaml(config), end=\"\")\n                    return\n\n                if flags[\"print_global\"]:\n                    # Print full tree from root\n                    root = current._get_root()\n                    full_path = \".\".join(consumed_path)\n                    root_overrides = [f\"{full_path}.{ov}\" for ov in overrides]\n                    all_configs = root._collect_configs(cfg_file, root_overrides)\n                    console.print(to_yaml(all_configs), end=\"\")\n                    return\n\n                # Execute the command\n                if config:\n                    func(config)\n                else:\n                    func()\n                return\n            else:\n                console.print(f\"[red]Error: Unknown command or group '{part}'[/red]\")\n                console.print(\n                    f\"[dim]Available: {list(current._commands.keys()) + list(current._groups.keys())}[/dim]\"\n                )\n                sys.exit(1)\n\n        # No command found - we're at a group level\n        if flags[\"help\"]:\n            current._show_help(console)\n            return\n\n        if flags[\"print\"] or flags[\"print_global\"]:\n            cfg_file = flags[\"cfg\"]\n            if flags[\"print_global\"] and current._parent:\n                # Print from root\n                root = current._get_root()\n                path = current._get_path()\n                root_overrides = [f\"{path}.{ov}\" if path else ov for ov in overrides]\n                all_configs = root._collect_configs(cfg_file, root_overrides)\n            else:\n                # Print from current node\n                all_configs = current._collect_configs(cfg_file, overrides)\n            console.print(to_yaml(all_configs), end=\"\")\n            return\n\n        # No command specified - show help\n        console.print(\"[yellow]No command specified. Use -h to see available commands.[/yellow]\")\n\n    def _show_help(self, console: Console) -&gt; None:\n        \"\"\"Show help for this group.\"\"\"\n        name = self._name or \"app\"\n\n        # Usage\n        console.print(\n            Panel(\n                f\"[bold]{name}[/bold] [cyan][OPTIONS][/cyan] [magenta]COMMAND[/magenta]\",\n                title=\"[bold blue]Usage[/bold blue]\",\n                border_style=\"blue\",\n            )\n        )\n        console.print()\n\n        # Description\n        if self._help:\n            console.print(self._help)\n            console.print()\n\n        # Options\n        if self._parent:\n            options_text = (\n                \"  [cyan]-c, --cfg PATH[/cyan]  Load config from YAML file\\n\"\n                \"  [cyan]-p[/cyan]              Print config and exit\\n\"\n                \"  [cyan]-g[/cyan]              Print root config (global) and exit\\n\"\n                \"  [cyan]-h[/cyan]              Show this help\"\n            )\n        else:\n            options_text = (\n                \"  [cyan]-c, --cfg PATH[/cyan]  Load config from YAML file\\n\"\n                \"  [cyan]-p[/cyan]              Print config and exit\\n\"\n                \"  [cyan]-h[/cyan]              Show this help\"\n            )\n        console.print(\n            Panel(\n                options_text,\n                title=\"[bold green]Options[/bold green]\",\n                title_align=\"left\",\n                border_style=\"green\",\n            )\n        )\n        console.print()\n\n        # Commands\n        all_items = list(self._commands.keys()) + list(self._groups.keys())\n        if all_items:\n            command_lines = []\n            max_len = max(len(name) for name in all_items) + 4\n\n            for cmd_name, (func, _) in self._commands.items():\n                help_text = (func.__doc__ or \"\").strip().split(\"\\n\")[0]\n                padding = \" \" * (max_len - len(cmd_name) - 2)\n                command_lines.append(\n                    f\"  [magenta]{cmd_name}[/magenta]{padding}[dim]{help_text}[/dim]\"\n                )\n\n            for group_name, sub_app in self._groups.items():\n                help_text = sub_app._help or \"\"\n                padding = \" \" * (max_len - len(group_name) - 2)\n                command_lines.append(\n                    f\"  [magenta]{group_name}[/magenta]{padding}[dim]{help_text}[/dim]\"\n                )\n\n            console.print(\n                Panel(\n                    \"\\n\".join(command_lines),\n                    title=\"[bold magenta]Commands[/bold magenta]\",\n                    title_align=\"left\",\n                    border_style=\"magenta\",\n                )\n            )\n\n    def _show_command_help(self, console: Console, name: str, schema: type | None) -&gt; None:\n        \"\"\"Show help for a specific command.\"\"\"\n        func, _ = self._commands[name]\n        group_name = self._name or \"app\"\n\n        # Usage\n        console.print(\n            Panel(\n                f\"[bold]{group_name} {name}[/bold] [cyan][OPTIONS][/cyan]\",\n                title=\"[bold blue]Usage[/bold blue]\",\n                border_style=\"blue\",\n            )\n        )\n        console.print()\n\n        if func.__doc__:\n            console.print(func.__doc__.strip())\n            console.print()\n\n        console.print(\"Override options with [cyan]key=value[/cyan]\")\n        console.print()\n\n        # Options\n        if self._parent:\n            options_text = (\n                \"  [cyan]-p[/cyan]  Print compiled config and exit\\n\"\n                \"  [cyan]-g[/cyan]  Print root config (global) and exit\\n\"\n                \"  [cyan]-h[/cyan]  Show this help\"\n            )\n        else:\n            options_text = (\n                \"  [cyan]-p[/cyan]  Print compiled config and exit\\n\"\n                \"  [cyan]-g[/cyan]  Print root config (global) and exit\\n\"\n                \"  [cyan]-h[/cyan]  Show this help\"\n            )\n        console.print(\n            Panel(\n                options_text,\n                title=\"[bold green]Options[/bold green]\",\n                title_align=\"left\",\n                border_style=\"green\",\n            )\n        )\n        console.print()\n\n        # Config\n        if schema:\n            _, config_opts = get_schema_structure(schema)\n            if config_opts:\n                config_lines = []\n                lengths = []\n                for name_opt, type_name, default, _ in config_opts:\n                    default_str = f\" = {default}\" if default is not None else \"\"\n                    lengths.append(len(f\"  {name_opt}: {type_name}{default_str}\"))\n\n                max_len = max(lengths) if lengths else 0\n\n                for i, (name_opt, type_name, default, help_text) in enumerate(config_opts):\n                    default_str = f\" [yellow]= {default}[/yellow]\" if default is not None else \"\"\n                    padding = \" \" * (max_len - lengths[i] + 2)\n                    help_str = f\"[dim]{help_text}[/dim]\" if help_text else \"\"\n                    config_lines.append(\n                        f\"  [cyan]{name_opt}[/cyan]: [green]{type_name}[/green]{default_str}{padding}{help_str}\"\n                    )\n\n                console.print(\n                    Panel(\n                        \"\\n\".join(config_lines),\n                        title=\"[bold cyan]Config[/bold cyan]\",\n                        title_align=\"left\",\n                        border_style=\"cyan\",\n                    )\n                )\n\n    def command(\n        self, name: str | None = None\n    ) -&gt; Callable[[Callable[..., Any]], Callable[..., Any]]:\n        \"\"\"Register a command.\"\"\"\n\n        def decorator(func: Callable[..., Any]) -&gt; Callable[..., Any]:\n            cmd_name = name or func.__name__\n\n            # Infer schema from function signature\n            from typing import get_type_hints\n\n            hints = get_type_hints(func)\n            schema = None\n            for pname, ptype in hints.items():\n                if pname != \"return\" and is_dataclass(ptype):\n                    schema = ptype\n                    break\n\n            self._commands[cmd_name] = (func, schema)  # type: ignore[assignment]\n            return func\n\n        return decorator\n\n    def group(self, name: str, help: str | None = None) -&gt; \"NanoCLI\":\n        \"\"\"Create a nested group.\"\"\"\n        sub_app = NanoCLI(name=name, help=help, parent=self)\n        self._groups[name] = sub_app\n        return sub_app\n</code></pre>"},{"location":"core/#nanocli.core.NanoCLI.__call__","title":"__call__","text":"<pre><code>__call__(args: list[str] | None = None) -&gt; None\n</code></pre> <p>Run the CLI.</p> Source code in <code>src/nanocli/core.py</code> <pre><code>def __call__(self, args: list[str] | None = None) -&gt; None:\n    \"\"\"Run the CLI.\"\"\"\n    if args is None:\n        args = sys.argv[1:]\n\n    self._execute(args)\n</code></pre>"},{"location":"core/#nanocli.core.NanoCLI.command","title":"command","text":"<pre><code>command(\n    name: str | None = None,\n) -&gt; Callable[[Callable[..., Any]], Callable[..., Any]]\n</code></pre> <p>Register a command.</p> Source code in <code>src/nanocli/core.py</code> <pre><code>def command(\n    self, name: str | None = None\n) -&gt; Callable[[Callable[..., Any]], Callable[..., Any]]:\n    \"\"\"Register a command.\"\"\"\n\n    def decorator(func: Callable[..., Any]) -&gt; Callable[..., Any]:\n        cmd_name = name or func.__name__\n\n        # Infer schema from function signature\n        from typing import get_type_hints\n\n        hints = get_type_hints(func)\n        schema = None\n        for pname, ptype in hints.items():\n            if pname != \"return\" and is_dataclass(ptype):\n                schema = ptype\n                break\n\n        self._commands[cmd_name] = (func, schema)  # type: ignore[assignment]\n        return func\n\n    return decorator\n</code></pre>"},{"location":"core/#nanocli.core.NanoCLI.group","title":"group","text":"<pre><code>group(name: str, help: str | None = None) -&gt; NanoCLI\n</code></pre> <p>Create a nested group.</p> Source code in <code>src/nanocli/core.py</code> <pre><code>def group(self, name: str, help: str | None = None) -&gt; \"NanoCLI\":\n    \"\"\"Create a nested group.\"\"\"\n    sub_app = NanoCLI(name=name, help=help, parent=self)\n    self._groups[name] = sub_app\n    return sub_app\n</code></pre>"},{"location":"core/#nanocli.core.parse_args","title":"nanocli.core.parse_args","text":"<pre><code>parse_args(\n    args: list[str],\n) -&gt; tuple[list[str], list[str], dict[str, Any]]\n</code></pre> <p>Parse CLI arguments into path, overrides, and flags.</p> <p>Separates command path segments, key=value overrides, and special flags.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>list[str]</code> <p>List of CLI arguments.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>Tuple of (path_parts, overrides, flags):</p> <code>list[str]</code> <ul> <li>path_parts: List of path segments (e.g., [\"data\", \"download\"])</li> </ul> <code>dict[str, Any]</code> <ul> <li>overrides: List of key=value overrides</li> </ul> <code>tuple[list[str], list[str], dict[str, Any]]</code> <ul> <li>flags: Dict with \"print\", \"print_global\", \"help\", \"cfg\"</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; path, overrides, flags = parse_args([\"train\", \"epochs=100\", \"-p\"])\n&gt;&gt;&gt; path\n['train']\n&gt;&gt;&gt; overrides\n['epochs=100']\n&gt;&gt;&gt; flags[\"print\"]\nTrue\n</code></pre> Source code in <code>src/nanocli/core.py</code> <pre><code>def parse_args(args: list[str]) -&gt; tuple[list[str], list[str], dict[str, Any]]:\n    \"\"\"Parse CLI arguments into path, overrides, and flags.\n\n    Separates command path segments, key=value overrides, and special flags.\n\n    Args:\n        args: List of CLI arguments.\n\n    Returns:\n        Tuple of (path_parts, overrides, flags):\n        - path_parts: List of path segments (e.g., [\"data\", \"download\"])\n        - overrides: List of key=value overrides\n        - flags: Dict with \"print\", \"print_global\", \"help\", \"cfg\"\n\n    Examples:\n        &gt;&gt;&gt; path, overrides, flags = parse_args([\"train\", \"epochs=100\", \"-p\"])\n        &gt;&gt;&gt; path\n        ['train']\n        &gt;&gt;&gt; overrides\n        ['epochs=100']\n        &gt;&gt;&gt; flags[\"print\"]\n        True\n    \"\"\"\n    path_parts = []\n    overrides = []\n    flags: dict[str, Any] = {\n        \"print\": False,\n        \"print_global\": False,\n        \"help\": False,\n        \"cfg\": None,\n    }\n\n    i = 0\n    while i &lt; len(args):\n        arg = args[i]\n\n        if arg in (\"-p\", \"--print\"):\n            flags[\"print\"] = True\n        elif arg in (\"-g\", \"--global\"):\n            flags[\"print_global\"] = True\n        elif arg in (\"-h\", \"--help\"):\n            flags[\"help\"] = True\n        elif arg in (\"-c\", \"--cfg\"):\n            if i + 1 &lt; len(args):\n                flags[\"cfg\"] = args[i + 1]\n                i += 1\n        elif \"=\" in arg:\n            overrides.append(arg)\n        else:\n            # Path segment (command or group name)\n            path_parts.append(arg)\n\n        i += 1\n\n    return path_parts, overrides, flags\n</code></pre>"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#installation","title":"Installation","text":"<pre><code>pip install nanocli\n# or\nuv pip install nanocli\n</code></pre>"},{"location":"getting-started/#your-first-cli","title":"Your First CLI","text":"<p>Create a simple CLI with typed configuration:</p> <pre><code>from dataclasses import dataclass\nfrom nanocli import group\n\n@dataclass\nclass Config:\n    name: str = \"world\"\n    count: int = 1\n\napp = group()\n\n@app.command()\ndef hello(cfg: Config):\n    for _ in range(cfg.count):\n        print(f\"Hello, {cfg.name}!\")\n\nif __name__ == \"__main__\":\n    app()\n</code></pre>"},{"location":"getting-started/#running-your-cli","title":"Running Your CLI","text":"<pre><code># Show help\npython app.py -h\n\n# Run with defaults\npython app.py hello\n\n# Override values\npython app.py hello name=Alice count=3\n\n# Print config\npython app.py hello -p\n\n# Load from YAML\npython app.py -c config.yml hello\n</code></pre>"},{"location":"getting-started/#nested-groups","title":"Nested Groups","text":"<p>Organize commands into groups:</p> <pre><code>app = group()\n\n@app.command()\ndef train(cfg: TrainConfig):\n    ...\n\ndata = app.group(\"data\", help=\"Data commands\")\n\n@data.command()\ndef download(cfg: DownloadConfig):\n    ...\n</code></pre> <pre><code>python app.py data download\npython app.py data download -g  # print global config\n</code></pre>"},{"location":"getting-started/#flags-reference","title":"Flags Reference","text":"Flag Meaning <code>-p</code> Print config from current node <code>-g</code> Print config from root (global) <code>-h</code> Show help <code>-c PATH</code> Load base config from YAML"}]}